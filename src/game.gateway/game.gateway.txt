import { WebSocketGateway, WebSocketServer, SubscribeMessage, OnGatewayInit, OnGatewayConnection, OnGatewayDisconnect } from '@nestjs/websockets';
import { Server, Socket } from 'socket.io';

enum Move {
  Rock = 'rock',
  Paper = 'paper',
  Scissors = 'scissors',
}

type Player = {
  id: string;
  move?: Move;
};

@WebSocketGateway()
export class RoshamboGateway implements OnGatewayInit, OnGatewayConnection, OnGatewayDisconnect {
  afterInit(server: any) {
    console.log('WebSocket server initialized');
  }
  
  @WebSocketServer() server: Server;

  
  private players: Player[] = [];
 

  handleConnection(client: Socket, ...args: any[]) {
    let count:number=0;
    console.log('Client connected:', client.id);
    this.players.push({ id: client.id });
    
   
  }

  handleDisconnect(client: Socket) {
    console.log('Client disconnected:', client.id);
    this.players = this.players.filter((player) => player.id !== client.id);
  }

  @SubscribeMessage('play')
   handlePlay(client: Socket, move: string) {
    

    const player = this.players.find((p) => p.id === client.id);
   
  console.log(this.players.length)
    
    if (player) {
      player.move = move as Move;
      console.log(`${player.id} played ${player.move}`);
       this.server.emit('user',`Player:${player.id} played ${player.move}`);
      if (this.players.every((p) => p.move)) {
        this.handleResult();
      }
    }
   }

  private handleResult() {
    const moves = this.players.map((p) => p.move);
    const result = this.calculateResult(moves);
    console.log('Result:', result);
    this.resetGame();
  }

  // private calculateResult(moves: Move[]) {
  //   const counts = {
  //     [Move.Rock]: 0,
  //     [Move.Paper]: 0,
  //     [Move.Scissors]: 0,
  //   };
  //   moves.forEach((move) => {
  //     counts[move]++;
  //   });
  //   if (counts[Move.Rock] && counts[Move.Paper] && counts[Move.Scissors]) {
  //     return 'tie';
  //   } else if (counts[Move.Rock] && counts[Move.Paper]) {
  //     return 'paper';
  //   } else if (counts[Move.Rock] && counts[Move.Scissors]) {
  //     return 'rock';
  //   } else if (counts[Move.Paper] && counts[Move.Scissors]) {
  //     return 'scissors';
  //   } else {
  //     return 'unknown';
  //   }
  // }

  private calculateResult(moves: Move[]) {
    const counts = {
      [Move.Rock]: 0,
      [Move.Paper]: 0,
      [Move.Scissors]: 0,
    };
    moves.forEach((move) => {
      counts[move]++;
    });
    if (counts[Move.Rock] === counts[Move.Paper] && counts[Move.Paper] === counts[Move.Scissors]) {
      return 'tie';
    } else if (counts[Move.Rock] > 0 && counts[Move.Paper] === 0 && counts[Move.Scissors] === 0) {
      return 'rock';
    } else if (counts[Move.Paper] > 0 && counts[Move.Rock] === 0 && counts[Move.Scissors] === 0) {
      return 'paper';
    } else if (counts[Move.Scissors] > 0 && counts[Move.Rock] === 0 && counts[Move.Paper] === 0) {
      return 'scissors';
    } else {
      return 'unknown';
    }
  }
  
  // private calculateResult(moves: Move[]) {
  //   const counts = {
  //     [Move.Rock]: 0,
  //     [Move.Paper]: 0,
  //     [Move.Scissors]: 0,
  //   };
  //   moves.forEach((move) => {
  //     counts[move]++;
  //   });
  //   if (counts[Move.Rock] > 0 && counts[Move.Paper] > 0 && counts[Move.Scissors] > 0) {
  //     return 'tie';
  //   } else if (counts[Move.Rock] > 0 && counts[Move.Paper] > 0 && counts[Move.Scissors] === 0) {
  //     return 'paper';
  //   } else if (counts[Move.Rock] > 0 && counts[Move.Scissors] > 0 && counts[Move.Paper] === 0) {
  //     return 'rock';
  //   } else if (counts[Move.Paper] > 0 && counts[Move.Scissors] > 0 && counts[Move.Rock] === 0) {
  //     return 'scissors';
  //   } else {
  //     return 'unknown';
  //   }
  // }
  // private calculateResult(moves: Move[]) {
  //   const counts = {
  //     [Move.Rock]: 0,
  //     [Move.Paper]: 0,
  //     [Move.Scissors]: 0,
  //   };
  //   moves.forEach((move) => {
  //     counts[move]++;
  //   });
  //   if (counts[Move.Rock] && counts[Move.Paper] && counts[Move.Scissors]) {
  //     return 'tie';
  //   } else if (counts[Move.Rock] && counts[Move.Paper] && !counts[Move.Scissors]) {
  //     return 'paper';
  //   } else if (counts[Move.Rock] && counts[Move.Scissors] && !counts[Move.Paper]) {
  //     return 'rock';
  //   } else if (counts[Move.Paper] && counts[Move.Scissors] && !counts[Move.Rock]) {
  //     return 'scissors';
  //   } else {
  //     return 'unknown';
  //   }
  // }
  

  private resetGame() {
    this.players.forEach((player) => {
      player.move = undefined;
    });
  }
}

